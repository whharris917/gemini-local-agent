--- a/tool_agent.py
+++ b/sandbox/tool_agent.py
@@ -254,16 +254,12 @@
             if not source_filename or not target_filename:
                 return {"status": "error", "message": "Could not determine source or target filename from diff header."}
 
-            # 2. Validate that the target path must be in the sandbox
-            if not target_filename.startswith('sandbox/'):
-                return {"status": "error", "message": "Target file path in diff header (+++ b/) must start with 'sandbox/'.\"}
-            
-            # Strip the 'sandbox/' prefix to use get_safe_path correctly
-            relative_target_filename = target_filename[len('sandbox/'):]
-            
+            # 2. The final output path must be in the sandbox for security.
+            # We derive the relative path from the full target_filename.
+            relative_target_filename = target_filename.split('sandbox/', 1)[-1] if 'sandbox/' in target_filename else target_filename
             try:
                 target_save_path = get_safe_path(relative_target_filename)
             except ValueError as e:
                 return {"status": "error", "message": str(e)}
 
             # 3. Handle overwrite confirmation
@@ -292,11 +288,15 @@
                 return read_result
             original_content = read_result['content']
 
-            # 6. Apply the patch using the patcher utility
-            new_content, error_message = patcher.apply_patch(diff_content, original_content, source_filename)
+            # 6. Create a temporary, in-memory version of the diff content where the
+            # target path matches the source path. This is required for the patch
+            # utility to work correctly in its isolated temporary directory.
+            internal_diff_content = diff_content.replace(f"+++ b/{target_filename}", f"+++ b/{source_filename}")
+
+            # 7. Apply the patch using the patcher utility with the modified diff
+            new_content, error_message = patcher.apply_patch(internal_diff_content, original_content, source_filename)
             
             if error_message:
-                return {"status": "error", "message": f"Failed to apply patch: {error_message}"}
+                return {"status": "error", "message": error_message}
 
-            # 7. Write the new, patched content to the validated target path
+            # 8. Write the new, patched content to the validated target path
             write_result = tpool.execute(_write_file, target_save_path, new_content)
             if write_result['status'] == 'error':
                 return write_result