--- a/app.py
+++ b/sandbox/app.py
@@ -3,11 +3,11 @@
 from flask_cors import CORS
 import google.generativeai as genai
 import os
+import atexit
 import logging
 import json
-import atexit
 from datetime import datetime
-from orchestrator import execute_reasoning_loop, confirmation_events
+from orchestrator_haven import execute_reasoning_loop, confirmation_events # MODIFIED
 from tool_agent import execute_tool_command, get_safe_path
 from memory_manager import MemoryManager
 from multiprocessing.managers import BaseManager
@@ -62,29 +62,8 @@
 # --- Setup Logging ---
 logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s', handlers=[logging.FileHandler("agent.log"), logging.StreamHandler()])
 
-# --- GEMINI SETUP ---
-model = None
-if API_KEY:
-    try:
-        genai.configure(api_key=API_KEY)
-        safety_settings = {
-            'HARM_CATEGORY_HARASSMENT': 'BLOCK_NONE',
-            'HARM_CATEGORY_HATE_SPEECH': 'BLOCK_NONE',
-            'HARM_CATEGORY_SEXUALLY_EXPLICIT': 'BLOCK_NONE',
-            'HARM_CATEGORY_DANGEROUS_CONTENT': 'BLOCK_NONE',
-        }
-        model = genai.GenerativeModel(
-            model_name=MODEL_DEFINITION,
-            system_instruction=SYSTEM_PROMPT,
-            safety_settings=safety_settings
-        )
-        logging.info("Gemini API configured successfully.")
-    except Exception as e:
-        logging.critical(f"FATAL: Failed to configure Gemini API. Error: {e}")
-else:
-    logging.critical("FATAL: Gemini API key not loaded.")
-
+# --- REMOVED: GEMINI SETUP (This now lives in the Haven) ---
+model = None # The 'model' variable is passed to some old functions, keep it as None.
 # --- API Usage Tracking ---
 def load_api_stats():
     try:
@@ -102,20 +81,20 @@
 api_stats = load_api_stats()
 atexit.register(save_api_stats)
 
-\"\"\"
-# --- NEW: Connect to the Haven to get the persistent session dictionary ---\
+# --- NEW: Connect to the Haven to get the remote Haven object ---
 class HavenManager(BaseManager):
     pass
 
-HavenManager.register('get_sessions')
-manager = HavenManager(address=('', 50000), authkey=b'phoenixhaven')
+HavenManager.register('get_haven')
+manager = HavenManager(address=('localhost', 50000), authkey=b'phoenixhaven')
 manager.connect()
-chat_sessions = manager.get_sessions()
-logging.info(\"Successfully connected to Haven and retrieved session dictionary.\")\n\"\"\"
-
-chat_sessions = {}
+haven = manager.get_haven()
+logging.info("Successfully connected to Haven and retrieved remote Haven object.")
+
+client_session_map = {} # Maps a client's temporary session_id to a persistent session_name
 
 # --- SERVER ROUTES & EVENTS ---
 @app.route('/')
@@ -165,30 +144,18 @@
     new_session_name = f"New_Session_{timestamp}"
     
     audit_log.log_event("Client Connected", session_id=session_id, session_name=new_session_name, source="Application", destination="Client", observers=["Application, Client"])
-    app.logger.info(f\"Client connected: {session_id}\")\n    if model:\n        try:\n            # --- MODIFIED: Initialize MemoryManager with the persistent session_name ---\n            memory = MemoryManager(session_name=new_session_name)\n            chat_sessions[session_id] = {\n                \"chat\": model.start_chat(history=memory.get_full_history()),\n                \"memory\": memory,\n                \"name\": new_session_name\n            }\n            app.logger.info(f\"Chat and MemoryManager session created for {session_id} with name {new_session_name}\")\n            \n-            audit_log.log_event(\"Socket.IO Emit: session_name_update\", session_id=session_id, session_name=new_session_name, source=\"Application\", destination=\"Client\", observers=[\"User\", \"Orchestrator\"], details={'name': new_session_name})\n-            socketio.emit('session_name_update', {'name': new_session_name}, to=session_id)\n-
-            # --- NEW: Send the (potentially loaded) history to the client ---\n            full_history = memory.get_full_history()\n            if full_history:\n                audit_log.log_event(\"Socket.IO Emit: full_history_update\", session_id=session_id, session_name=new_session_name, source=\"Application\", destination=\"Client\", observers=[\"User\"], details=f\"{len(full_history)} turns loaded\")\n                socketio.emit('load_chat_history', {'history': full_history}, to=session_id)\n-
-        except Exception as e:\n            app.logger.exception(f\"Could not create chat session for {session_id}.\")\n            socketio.emit('log_message', {'type': 'error', 'data': 'Failed to initialize AI session.'}, to=session_id)\n-    else:\n-        socketio.emit('log_message', {'type': 'error', 'data': 'AI model not available.'}, to=request.sid)\n+    app.logger.info(f"Client connected: {session_id}")
+    
+    # Create a new, temporary session for this connection
+    client_session_map[session_id] = new_session_name
+    haven.get_or_create_session(new_session_name)
+    
+    audit_log.log_event("Socket.IO Emit: session_name_update", session_id=session_id, session_name=new_session_name, source="Application", destination="Client", details={'name': new_session_name})
+    socketio.emit('session_name_update', {'name': new_session_name}, to=session_id)
 
 
 @socketio.on('disconnect')
 def handle_disconnect():
     session_id = request.sid
-    # Get the full session data before removing it.\n    session_data = chat_sessions.get(session_id)\n\n    if session_data:\n        session_name = session_data.get('name')\n        app.logger.info(f\"Client disconnected: {session_id}, Session: {session_name}\")\n        audit_log.log_event(\"Client Disconnected\", session_id=session_id, session_name=session_name, source=\"Client\", destination=\"Server\", observers=[\"Orchestrator\"])\n\n        # Check if the session was a default, unsaved session and clean it up.\n        if session_name and session_name.startswith(\"New_Session_\"):\n            try:\n                memory = session_data.get('memory')\n                if memory:\n                    app.logger.info(f\"Auto-deleting unsaved session collection: '{session_name}'\")\n                    memory.clear()  # This deletes the ChromaDB collection.\n                    audit_log.log_event(\n                        \"DB Collection Deleted\",\n                        session_id=session_id,\n                        session_name=session_name,\n                        source=\"System\",\n                        destination=\"Database\",\n                        observers=[\"Orchestrator\"],\n                        details=f\"Unsaved session '{session_name}' automatically cleaned up on disconnect.\"\n                    )\n            except Exception as e:\n                app.logger.error(f\"Error during automatic cleanup of session '{session_name}': {e}\")\n    else:\n        # Fallback for cases where session data might already be gone.\n        app.logger.info(f\"Client disconnected: {session_id} (No session data found).)\")\n        audit_log.log_event(\"Client Disconnected\", session_id=session_id, session_name=\"N/A\", source=\"Client\", destination=\"Server\", observers=[\"Orchestrator\"])\n-\n-    # Final cleanup of the application state.\n-    chat_sessions.pop(session_id, None)\n-    confirmation_events.pop(session_id, None)\n+    session_name = client_session_map.pop(session_id, "Unknown")
+    app.logger.info(f"Client disconnected: {session_id}, Session: {session_name}")
+    audit_log.log_event("Client Disconnected", session_id=session_id, session_name=session_name)
+    if session_name.startswith("New_Session_"):
+        haven.delete_session(session_name)
+        app.logger.info(f"Auto-deleting unsaved session '{session_name}' from Haven.")
 
 @socketio.on('start_task')
 def handle_start_task(data):
     session_id = request.sid
-    session_name = chat_sessions.get(session_id, {}).get('name')
-    audit_log.log_event(\"Socket.IO Event Received: start_task\", session_id=session_id, session_name=session_name, source=\"Client\", destination=\"Server\", observers=[\"Orchestrator\"], details=data)\n    prompt = data.get('prompt')\n    \n-    # Prepend timestamp to the user's prompt before processing\n     timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n     timestamped_prompt = f\"[{timestamp}] {prompt}\"\n     \n-    # Echo the timestamped prompt back to the user for immediate display\n     socketio.emit('display_user_prompt', {'prompt': timestamped_prompt}, to=session_id)\n 
-    session_data = chat_sessions.get(session_id)\n-    if prompt and session_data: # Check for original prompt here, not the timestamped one\n-        socketio.start_background_task(execute_reasoning_loop, socketio, session_data, timestamped_prompt, session_id, chat_sessions, model, api_stats)\n-    elif not session_data:\n-        socketio.emit('log_message', {'type': 'error', 'data': 'No active AI session. Please refresh.'}, to=request.sid)\n+    session_name = client_session_map.get(session_id)
+    prompt = data.get('prompt')
+    audit_log.log_event("Socket.IO Event Received: start_task", session_id=session_id, session_name=session_name, details=data)
+    
+    if prompt and session_name:
+        timestamped_prompt = f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {prompt}"
+        socketio.emit('display_user_prompt', {'prompt': timestamped_prompt}, to=session_id)
+        socketio.start_background_task(execute_reasoning_loop, socketio, session_id, session_name, timestamped_prompt, haven, api_stats)
+    else:
+        socketio.emit('log_message', {'type': 'error', 'data': 'Could not process task. Session not found.'}, to=session_id)
 
 @socketio.on('log_audit_event')
 def handle_audit_event(data):
     audit_log.log_event(
         event=data.get('event'),
         session_id=request.sid,
-        session_name=chat_sessions.get(request.sid, {}).get('name'),
+        session_name=client_session_map.get(request.sid, "Unknown"),
         loop_id=None,
         source=data.get('source'),
         destination=data.get('destination'),
@@ -291,24 +287,19 @@
 
 @socketio.on('user_confirmation')
 def handle_user_confirmation(data):\n    session_id = request.sid\n-    session_name = chat_sessions.get(session_id, {}).get('name')\n-    audit_log.log_event(\"Socket.IO Event Received: user_confirmation\", session_id=session_id, session_name=session_name, source=\"Client\", destination=\"Server\", observers=[\"Orchestrator\"], details=data)\n     event = confirmation_events.get(session_id)\n     if event:\n         event.send(data.get('response'))\n@@ -428,4 +419,4 @@
 \n         app.logger.info(\"Starting Unified Agent Server on http://127.0.0.1:5001\")\n         audit_log.log_event(\"SocketIO Server Started\", source=\"System\", destination=\"System\", observers=[\"Orchestrator\"])\n         socketio.run(app, port=5001)\n