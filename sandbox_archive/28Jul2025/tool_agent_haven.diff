--- a/tool_agent.py
+++ b/sandbox/tool_agent.py
@@ -10,6 +10,7 @@
 from code_parser import analyze_codebase, generate_mermaid_diagram
 import patcher
 import debugpy
+from multiprocessing.managers import BaseManager
 import builtins
 
 # --- Constants ---
@@ -100,7 +101,16 @@
     action = command.get('action')
     params = command.get('parameters', {})
     try:
-        chroma_client = chromadb.PersistentClient(path=CHROMA_DB_PATH)
+        # --- NEW: Connect to ChromaDB and Haven as needed ---
+        class HavenManager(BaseManager):
+            pass
+        HavenManager.register('get_sessions')
+        manager = HavenManager(address=('localhost', 50000), authkey=b'phoenixhaven')
+        
+        # These will only connect if not already connected
+        chroma_client = None
+        haven_sessions = None
+        
 
         if action == 'create_file':
             filename = params.get('filename', 'default.txt')
@@ -156,6 +166,13 @@
             else:
                 return {"status": "error", "message": f"Failed to list directory: {result['message']}"}
 
+        elif action == 'list_haven_sessions':
+            if not haven_sessions:
+                manager.connect()
+                haven_sessions = manager.get_sessions()
+            session_names = haven_sessions.list_sessions()
+            return {"status": "success", "message": f"Found {len(session_names)} sessions in Haven.", "sessions": session_names}
+
         elif action == 'delete_file':
             filename = params.get('filename')
             safe_path = get_safe_path(filename)
@@ -298,6 +315,8 @@
             return {"status": "success", "message": f"Patch applied successfully. File saved to '{target_filename}'."}
 
         # --- REFACTORED AND MODIFIED SESSION MANAGEMENT TOOLS ---
         elif action == 'save_session':
+            if not haven_sessions:
+                manager.connect()
+                haven_sessions = manager.get_sessions()
             session_name = params.get('session_name')
             if not session_name:
                 return {"status": "error", "message": "Session name not provided."}
@@ -306,14 +325,10 @@
             if not session_data or 'memory' not in session_data:
                 return {"status": "error", "message": "Active memory session not found."}
             
-            old_session_name = session_data.get('name')
-            memory = session_data['memory']
-            current_collection = memory.collection
-            if not current_collection:
-                 return {"status": "error", "message": "ChromaDB collection not found for this session."}
-
-            current_collection.modify(name=session_name)
-            memory.collection = chroma_client.get_collection(name=session_name)
+            old_session_name = client_session_map.get(session_id)
+            if not old_session_name:
+                return {"status": "error", "message": "Could not find current session name for this client."}
+
+            haven_sessions.rename_session(old_session_name, session_name)
             session_data['name'] = session_name
 
             audit_log.log_event(
@@ -326,6 +341,8 @@
             return {"status": "success", "message": f"Session '{session_name}' saved and session state updated."}
 
         elif action == 'list_sessions':
+            if not chroma_client:
+                chroma_client = chromadb.PersistentClient(path=CHROMA_DB_PATH)
             collections = chroma_client.list_collections()
             
             session_list = []
@@ -348,6 +365,8 @@
 
         elif action == 'load_session':
             from orchestrator import replay_history_for_client
+            if not haven_sessions:
+                manager.connect()
+                haven_sessions = manager.get_sessions()
             from memory_manager import MemoryManager # Import MemoryManager
 
             session_name = params.get('session_name')
@@ -361,6 +380,8 @@
                     try:
                         memory_to_clear = current_session_data.get('memory')
                         if memory_to_clear:
+                            # This is now handled by the Haven on disconnect.
+                            # We can likely remove this block later for cleanup.
                             logging.info(f"Auto-deleting unsaved collection '{current_session_name}' before loading new session.")
                             memory_to_clear.clear()
                             audit_log.log_event("DB Collection Deleted", session_id=session_id, session_name=current_session_name, source="System", destination="Database", details=f"Unsaved session '{current_session_name}' cleaned up.")
@@ -368,34 +389,16 @@
                         logging.error(f"Error during auto-cleanup: {e}")
 
             try:
-                collection = chroma_client.get_collection(name=session_name)
-                history_data = collection.get(include=["documents", "metadatas"])
+                # This ensures the session exists in the Haven, creating it if it's the first time
+                haven_sessions.get_or_create_session(session_name)
+                client_session_map[session_id] = session_name # Point this client to the new session
                 
-                full_history = []\n                if history_data and history_data['ids']:\n                    history_tuples = sorted(\n                        zip(history_data['documents'], history_data['metadatas']), \n                        key=lambda x: x[1].get('timestamp', 0)\n                    )\n                    for doc, meta in history_tuples:\n                        role = meta.get('role', 'unknown')\n                        content = doc\n                        # FIX: Handle both legacy (\"role: content\") and modern (\"content\") doc formats\n                        # Safely strip the \"role: \" prefix only if it's present, avoiding\n                        # accidental splitting of timestamps.\n                        if role == 'user' and doc.startswith('user: '):\n                            content = doc[len('user: '):]\n                        elif role == 'model' and doc.startswith('model: '):\n                            content = doc[len('model: '):]\n\n                        full_history.append({\"role\": role, \"parts\": [{'text': content.strip()}]})\n\n-                memory_manager = chat_sessions[session_id]['memory']\n-                memory_manager.collection = collection\n-                memory_manager.conversational_buffer = full_history\n-                memory_manager.session_name = session_name\n-                \n-                chat_sessions[session_id]['chat'] = model.start_chat(history=full_history)\n-                chat_sessions[session_id]['name'] = session_name\n-                \n                 socketio.emit('session_name_update', {'name': session_name}, to=session_id)\n 
-                # *** MODIFIED: Replay only the last part of the history ***\n-                history_for_replay = full_history[-memory_manager.max_buffer_size:]\n-                replay_history_for_client(socketio, session_id, session_name, history_for_replay)\n+                full_history = haven_sessions.get_full_history(session_name)
+                replay_history_for_client(socketio, session_id, session_name, full_history)
 
                 updated_list_result = execute_tool_command({'action': 'list_sessions'}, socketio, session_id, chat_sessions, model)
                 if updated_list_result.get('status') == 'success':
@@ -408,12 +411,15 @@
                 return {"status": "error", "message": f"Could not load session: {e}"}
         
         elif action == 'delete_session':
+            if not haven_sessions:
+                manager.connect()
+                haven_sessions = manager.get_sessions()
             session_name = params.get('session_name')
             if not session_name:
                 return {"status": "error", "message": "Session name not provided."}
             try:
-                chroma_client.delete_collection(name=session_name)
-                updated_list_result = execute_tool_command({'action': 'list_sessions'}, socketio, session_id, chat_sessions, model)
+                haven_sessions.delete_session(session_name)
+                updated_list_result = execute_tool_command({'action': 'list_sessions'}, socketio, session_id, haven_sessions, model)
                 if updated_list_result.get('status') == 'success':
                     socketio.emit('session_list_update', updated_list_result, to=session_id)
 
@@ -424,6 +430,8 @@
                 return {"status": "error", "message": f"Could not delete session: {e}"}
         
         elif action == 'import_legacy_sessions':
+            if not chroma_client:
+                chroma_client = chromadb.PersistentClient(path=CHROMA_DB_PATH)
             try:
                 with open(LEGACY_SESSIONS_FILE, 'r') as f:
                     legacy_sessions = json.load(f)