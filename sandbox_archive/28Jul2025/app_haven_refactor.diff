--- a/app.py
+++ b/sandbox/app.py
@@ -5,12 +5,13 @@
 import os
 import logging
 import json
+import time
 import atexit
 from datetime import datetime
 from orchestrator import execute_reasoning_loop, confirmation_events
 from tool_agent import execute_tool_command, get_safe_path
 from memory_manager import MemoryManager
 from multiprocessing.managers import BaseManager
 from audit_logger import audit_log
 import inspect_db as db_inspector
@@ -62,29 +63,6 @@
 # --- Setup Logging ---
 logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s', handlers=[logging.FileHandler("agent.log"), logging.StreamHandler()])
 
-# --- GEMINI SETUP ---
-model = None
-if API_KEY:
-    try:
-        genai.configure(api_key=API_KEY)
-        safety_settings = {
-            'HARM_CATEGORY_HARASSMENT': 'BLOCK_NONE',
-            'HARM_CATEGORY_HATE_SPEECH': 'BLOCK_NONE',
-            'HARM_CATEGORY_SEXUALLY_EXPLICIT': 'BLOCK_NONE',
-            'HARM_CATEGORY_DANGEROUS_CONTENT': 'BLOCK_NONE',
-        }
-        model = genai.GenerativeModel(
-            model_name=MODEL_DEFINITION,
-            system_instruction=SYSTEM_PROMPT,
-            safety_settings=safety_settings
-        )
-        logging.info("Gemini API configured successfully.")
-    except Exception as e:
-        logging.critical(f"FATAL: Failed to configure Gemini API. Error: {e}")
-else:
-    logging.critical("FATAL: Gemini API key not loaded.")
-
 # --- API Usage Tracking ---
 def load_api_stats():
     try:
@@ -101,20 +79,26 @@
 api_stats = load_api_stats()
 atexit.register(save_api_stats)
 
-\"\"\"
-# --- NEW: Connect to the Haven to get the persistent session dictionary ---\
+# --- NEW: Connect to the Haven to get the remote Haven object ---
 class HavenManager(BaseManager):
     pass
 
 HavenManager.register('get_sessions')
-manager = HavenManager(address=('localhost', 50000), authkey=b'phoenixhaven')
-manager.connect()
-chat_sessions = manager.get_sessions()
-logging.info(\"Successfully connected to Haven and retrieved session dictionary.\")\n\"\"\"
-
+manager = HavenManager(address=('localhost', 50000), authkey=b'phoenixhaven')
+
+for i in range(5): # Retry loop for robustness
+    try:
+        manager.connect()
+        logging.info("Successfully connected to Haven.")
+        break
+    except ConnectionRefusedError:
+        logging.warning(f"Haven connection refused. Retrying in {i+1} second(s)...")
+        time.sleep(i+1)
+
+chat_sessions = manager.get_sessions()
+
+# This local dict maps temporary client IDs to persistent session names
 client_session_map = {}
 
 # --- SERVER ROUTES & EVENTS ---
@@ -165,30 +149,15 @@
     new_session_name = f"New_Session_{timestamp}"
     
     audit_log.log_event("Client Connected", session_id=session_id, session_name=new_session_name, source="Application", destination="Client", observers=["Application, Client"])
-    app.logger.info(f\"Client connected: {session_id}\")\n    if model:\n        try:\n            # --- MODIFIED: Initialize MemoryManager with the persistent session_name ---\n            memory = MemoryManager(session_name=new_session_name)\n            chat_sessions[session_id] = {\n                \"chat\": model.start_chat(history=memory.get_full_history()),\n                \"memory\": memory,\n                \"name\": new_session_name\n            }\n            app.logger.info(f\"Chat and MemoryManager session created for {session_id} with name {new_session_name}\")\n            \n-            audit_log.log_event(\"Socket.IO Emit: session_name_update\", session_id=session_id, session_name=new_session_name, source=\"Application\", destination=\"Client\", observers=[\"User\", \"Orchestrator\"], details={'name': new_session_name})\n-            socketio.emit('session_name_update', {'name': new_session_name}, to=session_id)\n-\n-            # --- NEW: Send the (potentially loaded) history to the client ---\n-            full_history = memory.get_full_history()\n-            if full_history:\n-                audit_log.log_event(\"Socket.IO Emit: full_history_update\", session_id=session_id, session_name=new_session_name, source=\"Application\", destination=\"Client\", observers=[\"User\"], details=f\"{len(full_history)} turns loaded\")\n-                socketio.emit('load_chat_history', {'history': full_history}, to=session_id)\n-\n-        except Exception as e:\n-            app.logger.exception(f\"Could not create chat session for {session_id}.\")\n-            socketio.emit('log_message', {'type': 'error', 'data': 'Failed to initialize AI session.'}, to=session_id)\n-    else:\n-        socketio.emit('log_message', {'type': 'error', 'data': 'AI model not available.'}, to=request.sid)\n+    app.logger.info(f"Client connected: {session_id}")
+
+    # Store the mapping from the temporary client ID to our new persistent session name
+    client_session_map[session_id] = new_session_name
+
+    # Ask the Haven to create the session object if it doesn't exist
+    chat_sessions.get_or_create_session(new_session_name)
+
+    socketio.emit('session_name_update', {'name': new_session_name}, to=session_id)
 
 
 @socketio.on('disconnect')
 def handle_disconnect():
     session_id = request.sid
-    # Get the full session data before removing it.\n    session_data = chat_sessions.get(session_id)\n\n    if session_data:\n        session_name = session_data.get('name')\n        app.logger.info(f\"Client disconnected: {session_id}, Session: {session_name}\")\n        audit_log.log_event(\"Client Disconnected\", session_id=session_id, session_name=session_name, source=\"Client\", destination=\"Server\", observers=[\"Orchestrator\"])\n\n        # Check if the session was a default, unsaved session and clean it up.\n        if session_name and session_name.startswith(\"New_Session_\"):\n            try:\n                memory = session_data.get('memory')\n                if memory:\n                    app.logger.info(f\"Auto-deleting unsaved session collection: '{session_name}'\")\n                    memory.clear()  # This deletes the ChromaDB collection.\n                    audit_log.log_event(\n                        \"DB Collection Deleted\",\n                        session_id=session_id,\n                        session_name=session_name,\n                        source=\"System\",\n                        destination=\"Database\",\n                        observers=[\"Orchestrator\"],\n                        details=f\"Unsaved session '{session_name}' automatically cleaned up on disconnect.\"\n                    )\n            except Exception as e:\n                app.logger.error(f\"Error during automatic cleanup of session '{session_name}': {e}\")\n    else:\n        # Fallback for cases where session data might already be gone.\n        app.logger.info(f\"Client disconnected: {session_id} (No session data found).)\")\n        audit_log.log_event(\"Client Disconnected\", session_id=session_id, session_name=\"N/A\", source=\"Client\", destination=\"Server\", observers=[\"Orchestrator\"])\n-\n-    # Final cleanup of the application state.\n-    chat_sessions.pop(session_id, None)\n-    confirmation_events.pop(session_id, None)\n+    session_name = client_session_map.pop(session_id, None)
+    app.logger.info(f"Client disconnected: {session_id}, Session: {session_name or 'N/A'}")
+    
+    # If the disconnected session was a temporary 'New_Session', clean it up in the Haven
+    if session_name and session_name.startswith("New_Session_"):
+        chat_sessions.delete_session(session_name)
+        app.logger.info(f"Auto-deleting unsaved session '{session_name}' from Haven.")
 
 @socketio.on('start_task')
 def handle_start_task(data):\n    session_id = request.sid\n-    session_name = chat_sessions.get(session_id, {}).get('name')\n-    audit_log.log_event(\"Socket.IO Event Received: start_task\", session_id=session_id, session_name=session_name, source=\"Client\", destination=\"Server\", observers=[\"Orchestrator\"], details=data)\n     prompt = data.get('prompt')\n     \n-    # Prepend timestamp to the user's prompt before processing\n     timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n     timestamped_prompt = f\"[{timestamp}] {prompt}\"\n     \n-    # Echo the timestamped prompt back to the user for immediate display\n     socketio.emit('display_user_prompt', {'prompt': timestamped_prompt}, to=session_id)\n 
-    session_data = chat_sessions.get(session_id)\n-    if prompt and session_data: # Check for original prompt here, not the timestamped one\n-        socketio.start_background_task(execute_reasoning_loop, socketio, session_data, timestamped_prompt, session_id, chat_sessions, model, api_stats)\n-    elif not session_data:\n-        socketio.emit('log_message', {'type': 'error', 'data': 'No active AI session. Please refresh.'}, to=request.sid)\n+    session_name = client_session_map.get(session_id)
+    audit_log.log_event("Socket.IO Event Received: start_task", session_id=session_id, session_name=session_name, details=data)
+    
+    if prompt and session_name:
+        timestamped_prompt = f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {prompt}"
+        socketio.emit('display_user_prompt', {'prompt': timestamped_prompt}, to=session_id)
+        socketio.start_background_task(execute_reasoning_loop, socketio, session_id, session_name, timestamped_prompt, chat_sessions, api_stats)
+    else:
+        socketio.emit('log_message', {'type': 'error', 'data': 'Cannot start task: session not found.'}, to=session_id)
 
 @socketio.on('log_audit_event')
 def handle_audit_event(data):\n    audit_log.log_event(\n         event=data.get('event'),\n         session_id=request.sid,\n-        session_name=chat_sessions.get(request.sid, {}).get('name'),\n+        session_name=client_session_map.get(request.sid, "Unknown"),\n         loop_id=None,\n         source=data.get('source'),\n         destination=data.get('destination'),\n@@ -242,12 +224,12 @@
 @socketio.on('request_session_list')
 def handle_session_list_request():
     session_id = request.sid
-    session_name = chat_sessions.get(session_id, {}).get('name')
+    session_name = client_session_map.get(session_id, "Unknown")
     audit_log.log_event("Socket.IO Event Received: request_session_list", session_id=session_id, session_name=session_name, source="Client", destination="Server", observers=["Orchestrator"])
     tool_result = execute_tool_command({'action': 'list_sessions'}, socketio, session_id, chat_sessions, model)
     audit_log.log_event("Socket.IO Emit: session_list_update", session_id=session_id, session_name=session_name, source="Server", destination="Client", observers=["User"], details=tool_result)
     socketio.emit('session_list_update', tool_result, to=request.sid)
 
 @socketio.on('request_api_stats')
 def handle_api_stats_request():
-    session_id = request.sid\n    session_name = chat_sessions.get(session_id, {}).get('name')\n    audit_log.log_event(\"Socket.IO Event Received: request_api_stats\", session_id=session_id, session_name=session_name, source=\"Client\", destination=\"Server\", observers=[\"Orchestrator\"])\n    audit_log.log_event(\"Socket.IO Emit: api_usage_update\", session_id=session_id, session_name=session_name, source=\"Server\", destination=\"Client\", observers=[\"User\"], details=api_stats)\n     socketio.emit('api_usage_update', api_stats, to=request.sid)\n \n @socketio.on('request_session_name')\n def handle_session_name_request():\n     session_id = request.sid\n-    session_name = chat_sessions.get(session_id, {}).get('name')\n-    audit_log.log_event(\"Socket.IO Event Received: request_session_name\", session_id=session_id, session_name=session_name, source=\"Client\", destination=\"Server\", observers=[\"Orchestrator\"])\n-    session_data = chat_sessions.get(session_id)\n-    if session_data:\n-        name = session_data.get('name')\n-        audit_log.log_event(\"Socket.IO Emit: session_name_update\", session_id=session_id, session_name=name, source=\"Server\", destination=\"Client\", observers=[\"User\"], details={'name': name})\n-        socketio.emit('session_name_update', {'name': name}, to=request.sid)\n+    session_id = request.sid
+    session_name = client_session_map.get(session_id, "Unknown")
+    audit_log.log_event("Socket.IO Event Received: request_api_stats", session_id=session_id, session_name=session_name)
+    audit_log.log_event("Socket.IO Emit: api_usage_update", session_id=session_id, session_name=session_name, details=api_stats)
+    socketio.emit('api_usage_update', api_stats, to=request.sid)
+
+@socketio.on('request_session_name')
+def handle_session_name_request():
+    session_id = request.sid
+    session_name = client_session_map.get(session_id)
+    audit_log.log_event("Socket.IO Event Received: request_session_name", session_id=session_id, session_name=session_name)
+    if session_name:
+        audit_log.log_event("Socket.IO Emit: session_name_update", session_id=session_id, session_name=session_name, details={'name': session_name})
+        socketio.emit('session_name_update', {'name': session_name}, to=request.sid)
         
 # --- NEW: Socket.IO handlers for Database Viewer ---
 @socketio.on('request_db_collections')
 def handle_db_collections_request():
     session_id = request.sid
-    session_name = chat_sessions.get(session_id, {}).get('name', 'N/A')
+    session_name = client_session_map.get(session_id, "Unknown")
     audit_log.log_event(
         "DB Viewer: Collections Requested", 
         session_id=session_id, 
@@ -340,7 +322,7 @@
 @socketio.on('user_confirmation')
 def handle_user_confirmation(data):
     session_id = request.sid
-    session_name = chat_sessions.get(session_id, {}).get('name')
-    audit_log.log_event(\"Socket.IO Event Received: user_confirmation\", session_id=session_id, session_name=session_name, source=\"Client\", destination=\"Server\", observers=[\"Orchestrator\"], details=data)\n     event = confirmation_events.get(session_id)\n     if event:\n         event.send(data.get('response'))\n 
+    session_name = client_session_map.get(session_id, "Unknown")
+    audit_log.log_event("Socket.IO Event Received: user_confirmation", session_id=session_id, session_name=session_name, details=data)
+    event = confirmation_events.get(session_id)
+    if event:
+        event.send(data.get('response'))
+
 if __name__ == '__main__':
-    if not API_KEY:
-        app.logger.critical("Server startup failed: API key is missing.")
-    else:
-        # --- ACTIVATE THIS BLOCK FOR DEBUGGING ---
-        # use this: debugpy.breakpoint()
-        if False:
-            debugpy.listen((\"0.0.0.0\", 5678))\n            app.logger.info(\"Debugpy server listening on port 5678. Waiting for debugger to attach...\")\n            debugpy.wait_for_client()\n            app.logger.info(\"Debugger attached.\")\n\n-        app.logger.info(\"Starting Unified Agent Server on http://127.0.0.1:5001\")\n-        audit_log.log_event(\"SocketIO Server Started\", source=\"System\", destination=\"System\", observers=[\"Orchestrator\"])\n-        socketio.run(app, port=5001)\n+    app.logger.info("Starting Unified Agent Server on http://127.0.0.1:5001")
+    audit_log.log_event("SocketIO Server Started", source="System", destination="System", observers=["Orchestrator"])
+    socketio.run(app, port=5001)