--- a/orchestrator.py
+++ b/orchestrator.py
@@ -53,15 +53,30 @@

         if role == 'user':
             if raw_text.startswith(('TOOL_RESULT:', 'OBSERVATION:')):
+                # Attempt to parse the JSON part of the tool result for rich formatting.
                 try:
                     json_str = raw_text[raw_text.find('{'):]
                     tool_result = json.loads(json_str)
-                    log_message = tool_result.get('message', f"Tool executed.")
-                    socketio.emit('tool_log', {'data': f"[{log_message}]"}, to=session_id)
-                except json.JSONDecodeError:
-                    socketio.emit('tool_log', {'data': "[Tool action completed]"}, to=session_id)
+                    status = tool_result.get('status')
+                    message = tool_result.get('message', 'No message.')
+
+                    # Create a more descriptive log message based on the content
+                    if status == 'error':
+                        log_message = f"Error: {message}"
+                    elif 'directory_listing' in tool_result:
+                        listing = ', '.join(tool_result['directory_listing']) or "No files found."
+                        log_message = f"{message}: {listing}"
+                    elif 'file_content' in tool_result:
+                        log_message = f"{message}\n---\n{tool_result['file_content']}"
+                    else:
+                        log_message = message
+
+                    socketio.emit('tool_log', {'data': f"[{log_message}]"}, to=session_id) 
+                except (json.JSONDecodeError, IndexError):
+                    # Fallback for malformed or simple tool results
+                    socketio.emit('tool_log', {'data': f"[{raw_text}]"}, to=session_id)
+
             elif not raw_text.startswith('USER_CONFIRMATION:'):
                 socketio.emit('log_message', {'type': 'user', 'data': raw_text}, to=session_id)
         
         elif role == 'model':
             start_index, end_index = find_json_block(raw_text)
             if start_index is not None:
-                attachment = raw_text[:start_index].strip().strip('```json').strip('`')
-                if attachment:
-                    socketio.emit('log_message', {'type': 'info', 'data': attachment}, to=session_id)
-                
                 json_str = raw_text[start_index:end_index]
                 try:
                     command = json.loads(json_str)
                     action = command.get('action')
                     params = command.get('parameters', {})
-                    if action in ['respond', 'task_complete'] and params.get('response') and params.get('response').strip():
+                    attachment = raw_text[:start_index].strip().strip('```json').strip('`')
+
+                    # First, render the preamble text if it exists.
+                    if attachment:
+                        # If the action is terminal, the attachment is the final answer.
+                        if action in ['respond', 'task_complete']:
+                             socketio.emit('log_message', {'type': 'final_answer', 'data': attachment}, to=session_id)
+                             continue # Skip to next item in history
+                        else:
+                            # Otherwise, it's an informational message before a tool call.
+                            socketio.emit('log_message', {'type': 'info', 'data': attachment}, to=session_id)
+
+                    # Now, render the action itself.
+                    if action in ['respond', 'task_complete']:
+                        response = params.get('response', '').strip()
+                        if response:
+                            socketio.emit('log_message', {'type': 'final_answer', 'data': response}, to=session_id)
+                    elif action == 'request_confirmation':
+                        prompt = params.get('prompt')
+                        if prompt:
+                            socketio.emit('log_message', {'type': 'system_confirm', 'data': prompt}, to=session_id)
+                    else: # This handles all other tool calls
+                        socketio.emit('log_message', {'type': 'info', 'data': f"Agent used tool: {action}"}, to=session_id)
+
+                except json.JSONDecodeError:
+                    # If JSON parsing fails, render the whole block as a single response.
+                    if raw_text and raw_text.strip():
+                        socketio.emit('log_message', {'type': 'final_answer', 'data': raw_text}, to=session_id)
+            else:
+                # No JSON block found, just a simple text response.
                 if raw_text and raw_text.strip():
-                    socketio.emit('log_message', {'type': 'final_answer', 'data': raw_text}, to=session_id)
-            else:
-                if raw_text and raw_text.strip():
-                    socketio.emit('log_message', {'type': 'final_answer', 'data': raw_text}, to=session_id)
+                    socketio.emit('log_message', {'type': 'final_answer', 'data': raw_text}, to=session_id)
         socketio.sleep(0.01)
 
 def execute_reasoning_loop(socketio, session_data, initial_prompt, session_id, chat_sessions, model, api_stats):
