--- a/orchestrator.py
+++ b/orchestrator.py
@@ -250,33 +250,33 @@
 
 def _handle_payloads(prose, command_json):
     """
-    Checks for payload placeholders in command_json and replaces them with actual content,
-    as defined in the prose. Returns the stripped prose, updated command, and a list of placeholders that were found.
-    """
+    Finds and replaces payload placeholders (e.g., '@@PLACEHOLDER') in a command's parameters
+    with content defined in START/END blocks within the prose.
+    This version is designed to be robust against "nested" START/END markers within the payload content itself.
+    """
     placeholders_found = []
     if not command_json or 'parameters' not in command_json or not prose:
         return prose, command_json, placeholders_found
 
     params = command_json['parameters']
-    for key, value in params.items():
-        if isinstance(value, str) and value.startswith('@@'):
-            placeholder = value
-            start_marker = f\"START {placeholder}\"
-            end_marker = f\"END {placeholder}\"
-            
-            start_index = prose.find(start_marker)
-            end_index = prose.find(end_marker)
-            
-            if start_index != -1 and end_index != -1:
-                content_start = start_index + len(start_marker)
-                payload_content = prose[content_start:end_index].strip()
-                params[key] = payload_content
-                placeholders_found.append(placeholder)
-                logging.info(f\"Successfully extracted payload for '{placeholder}'.\")
-
+    
+    # Create a list of placeholders to process.
+    placeholders_to_process = [(k, v) for k, v in params.items() if isinstance(v, str) and v.startswith('@@')]
+
+    for key, placeholder in placeholders_to_process:
+        start_marker = f"START {placeholder}"
+        end_marker = f"END {placeholder}"
+
+        start_index = prose.find(start_marker)
+        if start_index == -1:
+            continue
+
+        # CRITICAL FIX: Search for the end marker *after* the start marker.
+        end_index = prose.find(end_marker, start_index)
+        if end_index == -1:
+            continue
+
+        # Extract content and update the command parameters.
+        content_start = start_index + len(start_marker)
+        payload_content = prose[content_start:end_index].strip()
+        params[key] = payload_content
+        placeholders_found.append(placeholder)
+        logging.info(f"Successfully extracted payload for '{placeholder}'.")
+
+    # After all placeholders are processed and params are updated, clean the prose.
     if placeholders_found:
-        for placeholder in placeholders_found:
-            start_marker = f\"START {placeholder}\"
-            end_marker = f\"END {placeholder}\"
-            start_index = prose.find(start_marker)
-            if start_index != -1:
-                end_index = prose.find(end_marker, start_index)
-                if end_index != -1:
-                    prose = prose.replace(prose[start_index : end_index + len(end_marker)], \"\").strip()
-
-    return prose, command_json, placeholders_found
+        temp_prose = prose
+        for placeholder in placeholders_found:
+            # Use a non-greedy regex to remove the entire block safely.
+            pattern = re.compile(f"START {re.escape(placeholder)}.*?END {re.escape(placeholder)}", re.DOTALL)
+            temp_prose = pattern.sub('', temp_prose)
+        prose = temp_prose.strip()
+
+    return prose, command_json, placeholders_found
 
 def replay_history_for_client(socketio, session_id, session_name, history):
     """