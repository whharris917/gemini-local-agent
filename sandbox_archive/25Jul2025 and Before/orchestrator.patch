--- a/orchestrator.py
+++ b/orchestrator.py
@@ -212,32 +212,30 @@
     return None
 
 # --- NEW: Function to handle multi-part payloads ---
-def _handle_payloads(command_json, raw_response_text):
-    """
-    Checks for payload placeholders and replaces them with actual content.
-    Returns the updated command and a list of placeholders that were found.
-    """
-    placeholders_found = []
-    if not command_json or 'parameters' not in command_json:
-        return command_json, placeholders_found
-
-    params = command_json['parameters']
-    for key, value in params.items():
-        if isinstance(value, str) and value.startswith('PAYLOAD_'):
-            placeholder = value
-            start_marker = f"START {placeholder}"
-            end_marker = f"END {placeholder}"
-            
-            start_index = raw_response_text.find(start_marker)
-            end_index = raw_response_text.find(end_marker)
-            
-            if start_index != -1 and end_index != -1:
-                content_start = start_index + len(start_marker)
-                payload_content = raw_response_text[content_start:end_index].strip()
-                params[key] = payload_content
-                placeholders_found.append(placeholder)
-                logging.info(f"Successfully extracted payload for '{placeholder}'.")
-
-    return command_json, placeholders_found
+def _handle_payloads(command_json, raw_response_text):
+    """
+    Checks for payload placeholders (e.g., '@PAYLOAD@') and replaces them
+    with content from between START/END markers in the raw response.
+    """
+    placeholders_found = []
+    if not command_json or 'parameters' not in command_json:
+        return command_json, placeholders_found
+
+    params = command_json['parameters']
+    # Use list(params.items()) to allow modification during iteration
+    for key, value in list(params.items()):
+        if isinstance(value, str) and value.startswith('@') and value.endswith('@'):
+            placeholder = value
+            start_marker = f"START {placeholder}"
+            end_marker = f"END {placeholder}"
+            
+            start_index = raw_response_text.find(start_marker)
+            end_index = raw_response_text.find(end_marker, start_index)
+            
+            if start_index != -1 and end_index != -1:
+                content_start = start_index + len(start_marker)
+                payload_content = raw_response_text[content_start:end_index].strip()
+                params[key] = payload_content
+                placeholders_found.append(placeholder)
+                logging.info(f"Successfully extracted payload for '{placeholder}'.")
+
+    return command_json, placeholders_found
 
 def replay_history_for_client(socketio, session_id, session_name, history):
     """
