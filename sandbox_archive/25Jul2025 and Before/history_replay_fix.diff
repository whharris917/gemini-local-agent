--- a/orchestrator.py
+++ b/orchestrator.py
@@ -298,40 +298,54 @@
     Parses the raw chat history and emits granular rendering events to the client,
     acting as a 'dry run' of the orchestrator's live logic.
     """
-    audit_log.log_event("History Replay Started", session_id=session_id, session_name=session_name, source="Orchestrator", destination="Client", details=f"Replaying {len(history)} turns.")
-    socketio.emit('clear_chat_history', to=session_id)
-    socketio.sleep(0.1)
-
-    for item in history:
-        role = item.get('role')
-        raw_text = ""
-        if item.get('parts') and isinstance(item['parts'], list) and len(item['parts']) > 0:
-            part = item['parts'][0]
-            if isinstance(part, dict) and 'text' in part:
-                raw_text = part.get('text', '')
-            elif isinstance(part, str):
-                raw_text = part
-        
-        if not raw_text or not raw_text.strip():
-            continue
-
-        if role == 'user':
-            if raw_text.startswith(('TOOL_RESULT:', 'OBSERVATION:')):
-                try:
-                    json_str = raw_text[raw_text.find('{'):]
-                    tool_result = json.loads(json_str)
-                    log_message = tool_result.get('message', f"Tool executed.")
-                    socketio.emit('tool_log', {'data': f"[{log_message}]"}, to=session_id)
-                except json.JSONDecodeError:
-                    socketio.emit('tool_log', {'data': "[Tool action completed]"}, to=session_id)
-            elif not raw_text.startswith('USER_CONFIRMATION:'):
-                socketio.emit('log_message', {'type': 'user', 'data': raw_text}, to=session_id)
-        
-        elif role == 'model':
-            prose, command_json = parse_agent_response(raw_text)
-            if prose:
-                socketio.emit('log_message', {'type': 'info', 'data': prose}, to=session_id)
-            if command_json:
-                action = command_json.get('action')
-                params = command_json.get('parameters', {})
-                if action in ['respond', 'task_complete'] and params.get('response') and params.get('response').strip():
-                    socketio.emit('log_message', {'type': 'final_answer', 'data': params['response']}, to=session_id)
-                elif action == 'request_confirmation' and params.get('prompt'):
-                    socketio.emit('log_message', {'type': 'system_confirm', 'data': params['prompt']}, to=session_id)                
-            """
-            start_index, end_index = find_json_block(raw_text)
-            if start_index is not None:
-                #attachment = raw_text[:start_index].strip().strip('```json').strip('`')
-                #if attachment:
-                #    socketio.emit('log_message', {'type': 'info', 'data': attachment}, to=session_id)
-                
-                json_str = raw_text[start_index:end_index]
-                # The rest of the string is the attachment
-                attachment = (raw_text[:start_index].strip().replace('```json', '') + raw_text[end_index:].strip().replace('```', '')).strip()
-                try:
-                    command = json.loads(json_str)
-                    action = command.get('action')
-                    params = command.get('parameters', {})
-                    if action in ['respond', 'task_complete'] and params.get('response') and params.get('response').strip():
-                        socketio.emit('log_message', {'type': 'final_answer', 'data': params['response']}, to=session_id)
-                    elif action == 'request_confirmation' and params.get('prompt'):
-                        socketio.emit('log_message', {'type': 'system_confirm', 'data': params['prompt']}, to=session_id)
-                except json.JSONDecodeError:
-                    if raw_text and raw_text.strip():
-                        socketio.emit('log_message', {'type': 'final_answer', 'data': raw_text}, to=session_id)
-            else:
-                if raw_text and raw_text.strip():
-                    socketio.emit('log_message', {'type': 'final_answer', 'data': raw_text}, to=session_id)
-            """
-        socketio.sleep(0.01)
+    try:
+        audit_log.log_event("History Replay Started", session_id=session_id, session_name=session_name, source="Orchestrator", destination="Client", details=f"Replaying {len(history)} turns.")
+        socketio.emit('clear_chat_history', to=session_id)
+        socketio.sleep(0.1)
+
+        for item in history:
+            role = item.get('role')
+            raw_text = (item.get('parts', [{}])[0] or {}).get('text', '')
+            if not raw_text or not raw_text.strip():
+                continue
+
+            if role == 'user':
+                if raw_text.startswith(('TOOL_RESULT:', 'OBSERVATION:')):
+                    try:
+                        json_str = raw_text[raw_text.find('{'):]
+                        tool_result = json.loads(json_str)
+                        log_message = tool_result.get('message', 'Tool action completed.')
+                        socketio.emit('tool_log', {'data': f"[{log_message}]"}, to=session_id)
+                    except (json.JSONDecodeError, IndexError):
+                        socketio.emit('tool_log', {'data': f"[{raw_text}]"}, to=session_id)
+                elif not raw_text.startswith('USER_CONFIRMATION:'):
+                    socketio.emit('log_message', {'type': 'user', 'data': raw_text}, to=session_id)
+            
+            elif role == 'model':
+                prose, command_json = parse_agent_response(raw_text)
+
+                if prose and not command_json:
+                    socketio.emit('log_message', {'type': 'final_answer', 'data': prose}, to=session_id)
+                    continue
+
+                if prose:
+                    socketio.emit('log_message', {'type': 'info', 'data': prose}, to=session_id)
+
+                if command_json:
+                    action = command_json.get('action')
+                    params = command_json.get('parameters', {})
+
+                    if action in ['respond', 'task_complete']:
+                        response = params.get('response', '').strip()
+                        if response:
+                            socketio.emit('log_message', {'type': 'final_answer', 'data': response}, to=session_id)
+                    elif action == 'request_confirmation':
+                        prompt = params.get('prompt')
+                        if prompt:
+                            socketio.emit('log_message', {'type': 'system_confirm', 'data': prompt}, to=session_id)
+                    else:
+                        socketio.emit('tool_log', {'data': f"(Agent decided to use tool: {action})"}, to=session_id)
+
+            socketio.sleep(0.01)
+    except Exception as e:
+        logging.error(f"Error during history replay for session {session_name}: {e}")
+        socketio.emit('log_message', {'type': 'error', 'data': f"Failed to replay history: {e}"}, to=session_id)
 
 def execute_reasoning_loop(socketio, session_data, initial_prompt, session_id, chat_sessions, model, api_stats):
     loop_id = str(uuid.uuid4())
