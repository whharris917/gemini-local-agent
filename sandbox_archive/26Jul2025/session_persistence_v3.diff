--- a/app.py
+++ b/sandbox/app_proposed.py
@@ -188,43 +188,59 @@
 
 @socketio.on('connect')
 def handle_connect():
-    session_id = request.sid
-    timestamp = datetime.now().strftime("%d%b%Y_%I%M%S%p").upper()
-    new_session_name = f"New_Session_{timestamp}"
-    
-    audit_log.log_event("Client Connected", session_id=session_id, session_name=new_session_name, source="Application", destination="Client", observers=["Application, Client"])
-    app.logger.info(f"Client connected: {session_id}")
-    if model:
-        try:
-            # --- MODIFIED: Initialize MemoryManager with the persistent session_name ---
-            memory = MemoryManager(session_name=new_session_name)
-            chat_sessions[session_id] = {
-                "chat": model.start_chat(history=memory.get_full_history()),
-                "memory": memory,
-                "name": new_session_name
-            }
-            app.logger.info(f"Chat and MemoryManager session created for {session_id} with name {new_session_name}")
-            
-            audit_log.log_event("Socket.IO Emit: session_name_update", session_id=session_id, session_name=new_session_name, source="Application", destination="Client", observers=["User", "Orchestrator"], details={'name': new_session_name})
-            socketio.emit('session_name_update', {'name': new_session_name}, to=session_id)
-
-            # --- NEW: Send the (potentially loaded) history to the client ---
-            full_history = memory.get_full_history()
-            if full_history:
-                audit_log.log_event("Socket.IO Emit: full_history_update", session_id=session_id, session_name=new_session_name, source="Application", destination="Client", observers=["User"], details=f"{len(full_history)} turns loaded")
-                socketio.emit('load_chat_history', {'history': full_history}, to=session_id)
-
-        except Exception as e:
-            app.logger.exception(f"Could not create chat session for {session_id}.")
-            socketio.emit('log_message', {'type': 'error', 'data': 'Failed to initialize AI session.'}, to=session_id)
-    else:
-        socketio.emit('log_message', {'type': 'error', 'data': 'AI model not available.'}, to=request.sid)
+    """
+    Handles a new client connection. This function only logs the connection.
+    Session initialization is now handled by the 'initialize_session' event.
+    """
+    session_id = request.sid
+    app.logger.info(f"Client connected: {session_id}. Waiting for session initialization.")
+    audit_log.log_event("Client Connected", session_id=session_id, source="Application", destination="Client", observers=["Application", "Client"], details="Waiting for client to emit 'initialize_session'.")
+
+
+@socketio.on('initialize_session')
+def handle_initialize_session(data):
+    """
+    Initializes a chat session for a connected client.
+    It can either resume a session by name or create a new temporary one.
+    The client is expected to send this event upon connection.
+    """
+    session_id = request.sid
+    requested_name = data.get('session_name') if data else None
+
+    if requested_name:
+        session_name = requested_name
+        event_name = "Session Resumed"
+        details = f"Client requested to resume session '{session_name}'."
+    else:
+        timestamp = datetime.now().strftime("%d%b%Y_%I%M%S%p").upper()
+        session_name = f"New_Session_{timestamp}"
+        event_name = "New Session Created"
+        details = f"Client did not request a session. Created new temporary session '{session_name}'."
+
+    audit_log.log_event(event_name, session_id=session_id, session_name=session_name, source="Application", destination="System", observers=["Orchestrator"], details=details)
+    app.logger.info(f"Attempting to initialize session '{session_name}' for client {session_id}")
+
+    if model:
+        try:
+            memory = MemoryManager(session_name=session_name)
+            chat_sessions[session_id] = {
+                "chat": model.start_chat(history=memory.get_full_history()),
+                "memory": memory,
+                "name": session_name
+            }
+            app.logger.info(f"Successfully initialized session '{session_name}' for {session_id}")
+
+            audit_log.log_event("Socket.IO Emit: session_name_update", session_id=session_id, session_name=session_name, source="Application", destination="Client", observers=["User", "Orchestrator"], details={'name': session_name})
+            socketio.emit('session_name_update', {'name': session_name}, to=session_id)
+
+            full_history = memory.get_full_history()
+            if full_history:
+                audit_log.log_event("Socket.IO Emit: full_history_update", session_id=session_id, session_name=session_name, source="Application", destination="Client", observers=["User"], details=f"{len(full_history)} turns loaded")
+                socketio.emit('load_chat_history', {'history': full_history}, to=session_id)
+
+        except Exception as e:
+            app.logger.exception(f"Could not create/load chat session '{session_name}' for {session_id}.")
+            socketio.emit('log_message', {'type': 'error', 'data': f'Failed to initialize AI session for {session_name}.'}, to=session_id)
+    else:
+        socketio.emit('log_message', {'type': 'error', 'data': 'AI model not available.'}, to=request.sid)
 
 
 @socketio.on('disconnect')
 def handle_disconnect():
     session_id = request.sid