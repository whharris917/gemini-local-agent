--- a/app.py
+++ b/sandbox/app_proposed.py
@@ -168,7 +168,8 @@
             chat_sessions[session_id] = {
                 "chat": model.start_chat(history=memory.get_full_history()),
                 "memory": memory,
-                "name": new_session_name
+                "name": new_session_name,
+                "state": "idle"  # NEW: Initialize session state
             }
             app.logger.info(f"Chat and MemoryManager session created for {session_id} with name {new_session_name}")
             
@@ -223,19 +224,30 @@
     session_id = request.sid
     session_name = chat_sessions.get(session_id, {}).get('name')
     audit_log.log_event("Socket.IO Event Received: start_task", session_id=session_id, session_name=session_name, source="Client", destination="Server", observers=["Orchestrator"], details=data)
+    
+    session_data = chat_sessions.get(session_id)
+    if not session_data:
+        socketio.emit('log_message', {'type': 'error', 'data': 'No active AI session. Please refresh.'}, to=request.sid)
+        return
+
+    # NEW: Check if a task is already running for this session
+    if session_data.get('state') == 'running':
+        audit_log.log_event("Task Rejected: Already Running", session_id=session_id, session_name=session_name, source="Server", destination="Client", details={"prompt": data.get('prompt')})
+        socketio.emit('log_message', {'type': 'error', 'data': 'A task is already in progress. Please wait for it to complete or stop it.'}, to=session_id)
+        return
+
     prompt = data.get('prompt')
-    
     # Prepend timestamp to the user's prompt before processing
     timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
     timestamped_prompt = f"[{timestamp}] {prompt}"
-    
     # Echo the timestamped prompt back to the user for immediate display
     socketio.emit('display_user_prompt', {'prompt': timestamped_prompt}, to=session_id)
 
-    session_data = chat_sessions.get(session_id)
     if prompt and session_data: # Check for original prompt here, not the timestamped one
+        session_data['state'] = 'running' # NEW: Set state to running
         socketio.start_background_task(execute_reasoning_loop, socketio, session_data, timestamped_prompt, session_id, chat_sessions, model, api_stats)
     elif not session_data:
         socketio.emit('log_message', {'type': 'error', 'data': 'No active AI session. Please refresh.'}, to=request.sid)
 
+@socketio.on('stop_task')
+def handle_stop_task():
+    session_id = request.sid
+    session_data = chat_sessions.get(session_id)
+    if session_data:
+        session_name = session_data.get('name')
+        audit_log.log_event("Halt Signal Received", session_id=session_id, session_name=session_name, source="Client", destination="Server")
+        app.logger.info(f"Received stop signal for session {session_id}. Setting state to 'idle'.")
+        session_data['state'] = 'idle'
+        socketio.emit('log_message', {'type': 'system', 'data': 'Stop signal received. Attempting to halt ongoing task...'}, to=session_id)
+
 @socketio.on('log_audit_event')
 def handle_audit_event(data):
     audit_log.log_event(