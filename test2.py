import os
import io
import sys
from contextlib import redirect_stdout
import json
import logging
from eventlet import tpool
import chromadb
import uuid
from audit_logger import audit_log 
from code_parser import analyze_codebase, generate_mermaid_diagram
import patcher
import debugpy

content = "import json\nimport logging\nfrom eventlet import tpool\nfrom eventlet.event import Event\nfrom tool_agent import execute_tool_command\nfrom audit_logger import audit_log\nimport uuid\nimport debugpy\n\nconfirmation_events = {}\n\ndef find_json_block(text):\n    \"\"\"\n    Finds the JSON block in a string by working backwards from the end\n    and balancing curly braces.\n    \"\"\"\n    end_index = text.rfind('}')\n    if end_index == -1:\n        return None, None\n\n    brace_count = 1\n    start_index = -1\n\n    for i in range(end_index - 1, -1, -1):\n        char = text[i]\n        if char == '}':\n            brace_count += 1\n        elif char == '{':\n            brace_count -= 1\n        \n        if brace_count == 0:\n            start_index = i\n            break\n\n    if start_index == -1:\n        return None, None\n\n    return start_index, end_index + 1\n\ndef replay_history_for_client(socketio, session_id, session_name, history):\n    \"\"\"\n    Parses the raw chat history and emits granular rendering events to the client,\n    acting as a 'dry run' of the orchestrator's live logic.\n    \"\"\"\n    audit_log.log_event(\"History Replay Started\", session_id=session_id, session_name=session_name, source=\"Orchestrator\", destination=\"Client\", details=f\"Replaying {len(history)} turns.\")\n    socketio.emit('clear_chat_history', to=session_id)\n    socketio.sleep(0.1)\n\n    for item in history:\n        role = item.get('role')\n        raw_text = \"\"\n        if item.get('parts') and isinstance(item['parts'], list) and len(item['parts']) > 0:\n            part = item['parts'][0]\n            if isinstance(part, dict) and 'text' in part:\n                raw_text = part.get('text', '')\n            elif isinstance(part, str):\n                raw_text = part\n        \n        if not raw_text or not raw_text.strip():\n            continue\n\n        if role == 'user':\n            if raw_text.startswith(('TOOL_RESULT:', 'OBSERVATION:')):\n                try:\n                    json_str = raw_text[raw_text.find('{'):]\n                    tool_result = json.loads(json_str)\n                    log_message = tool_result.get('message', f\"Tool executed.\")\n                    socketio.emit('tool_log', {'data': f\"[{log_message}]\"}, to=session_id)\n                except json.JSONDecodeError:\n                    socketio.emit('tool_log', {'data': \"[Tool action completed]\"}, to=session_id)\n            elif not raw_text.startswith('USER_CONFIRMATION:'):\n                socketio.emit('log_message', {'type': 'user', 'data': raw_text}, to=session_id)\n        \n        elif role == 'model':\n            start_index, end_index = find_json_block(raw_text)\n            if start_index is not None:\n                attachment = raw_text[:start_index].strip().strip('```json').strip('`')\n                if attachment:\n                    socketio.emit('log_message', {'type': 'info', 'data': attachment}, to=session_id)\n                \n                json_str = raw_text[start_index:end_index]\n                try:\n                    command = json.loads(json_str)\n                    action = command.get('action')\n                    params = command.get('parameters', {})\n                    if action in ['respond', 'task_complete'] and params.get('response') and params.get('response').strip():\n                        socketio.emit('log_message', {'type': 'final_answer', 'data': params['response']}, to=session_id)\n                    elif action == 'request_confirmation' and params.get('prompt'):\n                        socketio.emit('log_message', {'type': 'system_confirm', 'data': params['prompt']}, to=session_id)\n                except json.JSONDecodeError:\n                    if raw_text and raw_text.strip():\n                        socketio.emit('log_message', {'type': 'final_answer', 'data': raw_text}, to=session_id)\n            else:\n                if raw_text and raw_text.strip():\n                    socketio.emit('log_message', {'type': 'final_answer', 'data': raw_text}, to=session_id)\n        socketio.sleep(0.01)\n\ndef execute_reasoning_loop(socketio, session_data, initial_prompt, session_id, chat_sessions, model, api_stats):\n    loop_id = str(uuid.uuid4())\n    \n    def get_current_session_name():\n        return chat_sessions.get(session_id, {}).get('name')\n\n    audit_log.log_event(\"Reasoning Loop Started\", session_id=session_id, session_name=get_current_session_name(), loop_id=loop_id, source=\"Orchestrator\", destination=\"Orchestrator\", details={\"initial_prompt\": initial_prompt})\n    \n    try:\n        current_prompt = initial_prompt\n        destruction_confirmed = False\n\n        if not isinstance(session_data, dict):\n            logging.error(f\"Session data for {session_id} is not a dictionary.\")\n            return\n\n        chat = session_data.get('chat')\n        memory = session_data.get('memory')\n\n        if not chat or not memory:\n            logging.error(f\"Could not find chat or memory object for session {session_id}\")\n            socketio.emit('log_message', {'type': 'error', 'data': 'Critical error: Chat or Memory session object not found.'}, to=session_id)\n            return\n\n        observation_template = \"Tool Result: {tool_result_json}\"\n\n        for i in range(15):\n            socketio.sleep(0)\n            \n            retrieved_context = memory.get_context_for_prompt(current_prompt)\n\n            final_prompt = current_prompt\n            if retrieved_context:\n                context_str = \"\\n\".join(retrieved_context)\n                final_prompt = (\n                    \"CONTEXT FROM PAST CONVERSATIONS:\\n\"\n                    f\"{context_str}\\n\\n\"\n                    \"Based on the above context, please respond to the following prompt:\\n\"\n                    f\"{current_prompt}\"\n                )\n                logging.info(f\"Augmented prompt with {len(retrieved_context)} documents from memory.\")\n\n            memory.add_turn(\"user\", current_prompt)\n\n            audit_log.log_event(\"Gemini API Call Sent\", session_id=session_id, session_name=get_current_session_name(), loop_id=loop_id, source=\"Orchestrator\", destination=\"Model\", observers=[\"Orchestrator\", \"Model\"], details={\"prompt\": final_prompt})\n            response = tpool.execute(chat.send_message, final_prompt)\n            audit_log.log_event(\"Gemini API Response Received\", session_id=session_id, session_name=get_current_session_name(), loop_id=loop_id, source=\"Model\", destination=\"Orchestrator\", observers=[\"Orchestrator\", \"Model\"], details={\"response_text\": response.text})\n\n            if response.usage_metadata:\n                api_stats['total_calls'] += 1\n                api_stats['total_prompt_tokens'] += response.usage_metadata.prompt_token_count\n                api_stats['total_completion_tokens'] += response.usage_metadata.candidates_token_count\n                socketio.emit('api_usage_update', api_stats)\n            \n            response_text = response.text\n            memory.add_turn(\"model\", response_text)\n\n            try:\n                start_index, end_index = find_json_block(response_text)\n                \n                if start_index is not None:\n                    json_str = response_text[start_index:end_index]\n                    attachment_text = response_text[:start_index].strip().strip('```json').strip('`')\n                    command_json = json.loads(json_str)\n\n                    if attachment_text:\n                        command_json['attachment'] = attachment_text\n                        audit_log.log_event(\"Socket.IO Emit: log_message\", session_id=session_id, session_name=get_current_session_name(), loop_id=loop_id, source=\"Orchestrator\", destination=\"Client\", observers=[\"User\"], details={'type': 'info', 'data': attachment_text})\n                        socketio.emit('log_message', {'type': 'info', 'data': attachment_text}, to=session_id)\n                else:\n                    command_json = {\"action\": \"respond\", \"parameters\": {\"response\": response_text}}\n\n            except json.JSONDecodeError:\n                logging.warning(f\"Could not decode JSON from model response. Treating as plain text. Response: {response_text}\")\n                command_json = {\"action\": \"respond\", \"parameters\": {\"response\": response_text}}\n            \n            action = command_json.get(\"action\")\n\n            if action == 'respond':\n                response_to_user = command_json.get('parameters', {}).get('response', '')\n                if response_to_user and response_to_user.strip():\n                    audit_log.log_event(\"Socket.IO Emit: log_message\", session_id=session_id, session_name=get_current_session_name(), loop_id=loop_id, source=\"Orchestrator\", destination=\"Client\", observers=[\"User\", \"Orchestrator\"], details={'type': 'final_answer', 'data': response_to_user})\n                    socketio.emit('log_message', {'type': 'final_answer', 'data': response_to_user}, to=session_id)\n                return\n            \n            if action == 'task_complete':\n                final_response = command_json.get('parameters', {}).get('response')\n                if final_response and final_response.strip():\n                    audit_log.log_event(\"Socket.IO Emit: log_message\", session_id=session_id, session_name=get_current_session_name(), loop_id=loop_id, source=\"Orchestrator\", destination=\"Client\", observers=[\"User\", \"Orchestrator\"], details={'type': 'final_answer', 'data': final_response})\n                    socketio.emit('log_message', {'type': 'final_answer', 'data': final_response}, to=session_id)\n                logging.info(f\"Agent initiated task_complete. Ending loop for session {session_id}.\")\n                return\n\n            destructive_actions = ['delete_file', 'delete_session']\n            if action in destructive_actions and not destruction_confirmed:\n                err_msg = f\"Action '{action}' is destructive and requires user confirmation. I must use 'request_confirmation' first.\"\n                logging.warning(err_msg)\n                error_payload = {'status': 'error', 'message': err_msg}\n                current_prompt = observation_template.format(tool_result_json=json.dumps(error_payload))\n                destruction_confirmed = False\n                continue\n\n            if action == 'request_confirmation':\n                prompt_text = command_json.get('parameters', {}).get('prompt', 'Are you sure?')\n                confirmation_event = Event()\n                confirmation_events[session_id] = confirmation_event\n                audit_log.log_event(\"Socket.IO Emit: request_user_confirmation\", session_id=session_id, session_name=get_current_session_name(), loop_id=loop_id, source=\"Orchestrator\", destination=\"Client\", observers=[\"User\", \"Orchestrator\"], details={'prompt': prompt_text})\n                socketio.emit('request_user_confirmation', {'prompt': prompt_text}, to=session_id)\n                user_response = confirmation_event.wait()\n                confirmation_events.pop(session_id, None)\n                if user_response == 'yes':\n                    destruction_confirmed = True\n                else:\n                    destruction_confirmed = False\n                current_prompt = f\"USER_CONFIRMATION: '{user_response}'\"\n                continue\n\n            audit_log.log_event(\"Tool Agent Call Sent\", session_id=session_id, session_name=get_current_session_name(), loop_id=loop_id, source=\"Orchestrator\", destination=\"Tool Agent\", observers=[\"Orchestrator\", \"Tool Agent\"], details=command_json)\n            tool_result = execute_tool_command(command_json, socketio, session_id, chat_sessions, model)            \n            audit_log.log_event(\"Tool Agent Execution Finished\", session_id=session_id, session_name=get_current_session_name(), loop_id=loop_id, source=\"Tool Agent\", destination=\"Orchestrator\", observers=[\"Orchestrator\", \"Tool Agent\"], details=tool_result)\n\n            destruction_confirmed = False\n\n            if tool_result.get('status') == 'success':\n                log_message = tool_result.get('message', f\"Tool '{action}' executed successfully.\")\n                audit_log.log_event(\"Socket.IO Emit: tool_log\", session_id=session_id, session_name=get_current_session_name(), loop_id=loop_id, source=\"Orchestrator\", destination=\"Client\", observers=[\"User\", \"Orchestrator\"], details={'data': f\"[{log_message}]\"})\n                socketio.emit('tool_log', {'data': f\"[{log_message}]\"}, to=session_id)\n            else:\n                pass\n\n            current_prompt = observation_template.format(tool_result_json=json.dumps(tool_result))\n\n    except Exception as e:\n        logging.exception(\"An error occurred in the reasoning loop.\")\n        socketio.emit('log_message', {'type': 'error', 'data': f\"An error occurred during reasoning: {str(e)}\"}, to=session_id)\n    finally:\n        audit_log.log_event(\"Reasoning Loop Ended\", session_id=session_id, session_name=get_current_session_name(), loop_id=loop_id, source=\"Orchestrator\", destination=\"Orchestrator\", observers=[\"Orchestrator\"])\n"

with open('./sandbox/orchestrator_proposed.py', 'w', encoding='utf-8') as f:
    f.write(content)
