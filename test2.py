import os
import io
import sys
from contextlib import redirect_stdout
import json
import logging
from eventlet import tpool
import chromadb
import uuid
from audit_logger import audit_log 
from code_parser import analyze_codebase, generate_mermaid_diagram
import patcher
import debugpy

content = "### Step 1: Replace the `find_json_block` function\n\nPlease delete the entire `find_json_block` function in `orchestrator.py` and replace it with this new, more robust version:\n\n```python\ndef find_and_extract_json_with_prose(text):\n    \"\"\"\n    Finds a JSON block, prioritizing markdown fences, and separates it from surrounding text.\n    Returns a tuple: (json_string, prose_string)\n    \"\"\"\n    # Prioritize finding a markdown-fenced JSON block\n    start_marker = '```json'\n    end_marker = '```'\n    start_pos = text.find(start_marker)\n\n    if start_pos != -1:\n        end_pos = text.find(end_marker, start_pos + len(start_marker))\n        if end_pos != -1:\n            json_str = text[start_pos + len(start_marker):end_pos].strip()\n            prose_str = (text[:start_pos].strip() + ' ' + text[end_pos + len(end_marker):].strip()).strip()\n            return json_str, prose_str\n\n    # Fallback to brace-counting from the end if no markdown block is found\n    end_brace_pos = text.rfind('}')\n    if end_brace_pos == -1:\n        return None, text # No JSON found, return original text as prose\n\n    brace_count = 1\n    start_brace_pos = -1\n    for i in range(end_brace_pos - 1, -1, -1):\n        if text[i] == '}': brace_count += 1\n        elif text[i] == '{': brace_count -= 1\n        if brace_count == 0:\n            start_brace_pos = i\n            break\n\n    if start_brace_pos != -1:\n        json_str = text[start_brace_pos:end_brace_pos + 1]\n        prose_str = text[:start_brace_pos].strip()\n        return json_str, prose_str\n\n    return None, text # No JSON found, return original text as prose\n```\n\n### Step 2: Replace the JSON Parsing Block\n\nIn `execute_reasoning_loop`, please find and delete the entire block of code that starts with `command_json = None` and ends just before `action = command_json.get(\"action\")`. Replace it with this new logic:\n\n```python\n            # --- NEW, ROBUST JSON PARSING LOGIC ---\n            command_json = None\n            json_str, attachment_text = find_and_extract_json_with_prose(response_text)\n\n            if json_str:\n                # A potential JSON block was found. Try to parse/heal it.\n                max_repair_attempts = 10\n                for attempt in range(max_repair_attempts):\n                    try:\n                        command_json = json.loads(json_str)\n                        if attempt > 0:\n                            logging.info(f\"Successfully repaired JSON after {attempt} attempts.\")\n                        break # Success!\n                    except json.JSONDecodeError as e:\n                        offending_quote_pos = json_str.rfind('\"', 0, e.pos + 1)\n                        if offending_quote_pos != -1:\n                            logging.warning(f\"Attempting JSON repair {attempt + 1}/{max_repair_attempts}. Error: {e}\")\n                            json_str = json_str[:offending_quote_pos] + '\\\\' + json_str[offending_quote_pos:]\n                        else:\n                            logging.error(f\"JSON repair failed on attempt {attempt+1}. Could not find quote to escape.\")\n                            command_json = None\n                            break # Unfixable error\n\n                if command_json and attachment_text:\n                    command_json['attachment'] = attachment_text\n                    audit_log.log_event(\"Socket.IO Emit: log_message\", session_id=session_id, session_name=get_current_session_name(), loop_id=loop_id, source=\"Orchestrator\", destination=\"Client\", observers=[\"User\"], details={'type': 'info', 'data': attachment_text})\n                    socketio.emit('log_message', {'type': 'info', 'data': attachment_text}, to=session_id)\n\n            if not command_json:\n                # If no JSON was found or parsing/healing failed, treat the whole response as prose.\n                logging.warning(f\"Could not decode JSON from model response. Treating as plain text.\")\n                command_json = {\"action\": \"respond\", \"parameters\": {\"response\": response_text}}\n            # --- END OF NEW PARSING LOGIC ---\n```\n\nPlease let me know when you have applied these changes. I will be ready to test."

with open('./sandbox/desperate_fix.txt', 'w', encoding='utf-8') as f:
    f.write(content)
